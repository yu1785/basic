package com.atguigu.reflection;

import java.util.Random;

import org.junit.Test;

/**
 * 	通过反射创建运行时类的对象
 * @author dell
 *
 */
public class NewInstanceTest {
	
	@Test
	public void test1() throws InstantiationException, IllegalAccessException {
		
		Class cla = Person.class;
		/**
		 * 	newInstance()  调用此方法 ， 创建对应的运行时类的对象
		 * 	内部调用了运行时类的空参构造器
		 * 
		 * 	要想此方法正常创建对应的运行时类的对象  要求：
		 * 	1 运行时类必须提供空参构造器
		 * 	2 空参构造器的访问权限得够  通常设置为public
		 * 
		 * 	javabean 中要求提供空参构造器  原因：
		 * 	1 便于通过反射 创建运行时类的对象
		 * 	2 便于子类继承此运行时类时  默认调用super()时 保证父类有此构造器 
		 */
		Object obj = cla.newInstance();
		System.out.println(obj);
		
	}
	
	// 反射的动态性
	@Test
	public void test2() throws Exception{
		
		for (int i = 0; i < 100; i++) {
			int num = new Random().nextInt(3);
			String classPath = "";
			switch (num) {
				case 0:
					classPath = "java.util.Date";
					break;
				case 1:
					classPath = "java.lang.Object";
					break;
				case 2:
					classPath = "com.atguigu.reflection";
					break;
			}
			
			try {
				Object obj = getInstance(classPath);
				System.out.println(obj);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
//		Class cla = Class.forName("com.atguigu.reflection.Person");
//		Object obj = cla.newInstance();
//		System.out.println(obj);
	}
	
	public Object getInstance(String classPath) throws Exception{
		Class cla = Class.forName(classPath);
		return cla.newInstance();
	}
	
	
	
}
